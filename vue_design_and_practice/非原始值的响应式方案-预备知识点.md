### 预备知识点
- Proxy和Reflect
    1. Proxy
        1.1 使用Proxy可以创建一个代理对象
        1.2 它能够实现对其他对象的代理，这里的关键词是其他对象，也就是说，Proxy 只能代理对象，无法代理非对象值，例如字符串、布尔值等
        1.3 所谓代理，指的是对一个对象基本语义的代理, Proxy只能够拦截对一个对象的基本操作
        1.4 基本操作: 对对象的读取,设置等操作, 或者调用函数
        1.5 复合操作: 基本操作的组合
        例如: 第一个基本语义是get，即先通过 get 操作得到 obj.fn 属性。第二个基本语义是函数调用，即通过get 得到 obj.fn 的值后再调用它，也就是我们上面说到的 apply
        ```JavaScript
            obj.fn()
        ```
    2. Reflect
       2.1 提供了访问一个对象属性的默认行为
       2.2 receiver可以把它简单地理解为函数调用中的 this
       ```JavaScript
          Reflect.get(target, key, receiver)
       ```
- JavaScript中的对象: 根据ECMAScript 规范, 将对象分为常规对象和异质对象
    1. 区分对象: 对象的实际语义是由对象的内部方法（internal method）指定的
    2. 内部方法: 指的是当我们对一个对象进行操作时在引擎内部调用的方法，这些方法对于 JavaScript 使用者来说是不可见的
    3. 访问对象属性时: 引擎内部会调用 [[Get]] 这个内部方法来读取属性值
    ```JavaScript
       obj.foo
    ```
    4. 常见的内部方法: [[Get]], [[Set]], [[Delete]], [[GetOwnProperty]], [[HasProperty]], [[OwnPropertyKeys]],[[Call]], [[Construct]]
    5. 区分一个对象是普通对象还是函数: 通过内部方法和内部槽来区分对象，例如函数对象会部署内部方法 [[Call]]，而普通对象则不会
    6. Proxy创建的代理对象:
        1. 如果创建代理对象时,没有指定对应的拦截函数(例如:get, set), 那么当访问代理对象时,代理对象的内部方法[[Get]], [[Set]]就会去调用原始对象的内部方法[[Get]], [[Set]]来获取属性值
        2. 创建代理对象时指定的拦截函数，实际上是用来自定义代理对象本身的内部方法和行为的，而不是用来指定被代理对象的内部方法和行为的
    7. deleteProperty 实现的是代理对象 p 的内部方法和行为，所以为了删除被代理对象上的属性值，我们需要使用Reflect.deleteProperty(target, key) 来完成
    ```JavaScript
        const obj = { foo: 1 }
        const p = new Proxy(obj, {
            deleteProperty(target, key) {
                return Reflect.deleteProperty(target, key)
            }
        })
    ```